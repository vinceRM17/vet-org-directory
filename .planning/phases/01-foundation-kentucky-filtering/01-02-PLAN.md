---
phase: 01-foundation-kentucky-filtering
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - main.py
  - config/settings.py
  - transformers/enricher.py
autonomous: true

must_haves:
  truths:
    - "Pipeline filters to Kentucky orgs before Stage 7 web enrichment runs"
    - "Enrichment saves checkpoint every 100 orgs (not 500)"
    - "Enrichment displays tqdm progress bar with estimated time remaining"
    - "Kentucky filter can be bypassed via CLI flag for full pipeline runs"
  artifacts:
    - path: "main.py"
      provides: "Kentucky state filter between Stage 6 and Stage 7"
      contains: "kentucky_filter"
    - path: "config/settings.py"
      provides: "Updated checkpoint interval of 100"
      contains: "CHECKPOINT_INTERVAL = 100"
    - path: "transformers/enricher.py"
      provides: "tqdm progress bar in enrichment loop"
      contains: "from tqdm import tqdm"
  key_links:
    - from: "main.py"
      to: "transformers/enricher.py"
      via: "stage7_enrichment receives Kentucky-filtered DataFrame"
      pattern: "stage7_enrichment"
    - from: "transformers/enricher.py"
      to: "config/settings.py"
      via: "imports CHECKPOINT_INTERVAL for save frequency"
      pattern: "CHECKPOINT_INTERVAL"
    - from: "transformers/enricher.py"
      to: "tqdm"
      via: "progress bar wrapping enrichment loop"
      pattern: "tqdm\\(remaining"
---

<objective>
Add Kentucky state filtering before Stage 7 enrichment and improve the enrichment loop with progress bars and more frequent checkpoints.

Purpose: Web enrichment (Stage 7) scrapes org websites for emails, phones, and social media -- an expensive operation at ~2 seconds per org. Filtering to Kentucky first reduces scope from 80K to 2-5K orgs (16-40x speedup). Adding tqdm progress bars gives the user real-time feedback with ETA. Reducing checkpoint interval from 500 to 100 improves crash resilience for the slower web scraping operations.

Output: Updated `main.py` with Kentucky filter stage, updated `config/settings.py` with checkpoint interval of 100, and updated `transformers/enricher.py` with tqdm progress bar.
</objective>

<execution_context>
@/Users/vincecain/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vincecain/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@main.py
@config/settings.py
@transformers/enricher.py
@utils/checkpoint.py
@.planning/phases/01-foundation-kentucky-filtering/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Kentucky state filter to pipeline</name>
  <files>main.py</files>
  <action>
Add a Kentucky state filter in `main.py` that runs between Stage 6 (dedup) and Stage 7 (enrichment). This reduces the web enrichment scope from 80K to ~2-5K orgs.

1. **Add a new CLI argument** `--state-filter` to the argument parser:
   ```python
   parser.add_argument(
       "--state-filter", type=str, default=None,
       help="Filter to specific state before enrichment (e.g., 'KY' for Kentucky)"
   )
   ```
   This makes the filter configurable rather than hard-coded to Kentucky. Default is None (no filtering, for backward compatibility).

2. **Create a filter function** between `stage6_dedup()` and `stage7_enrichment()`:
   ```python
   def filter_by_state(df: pd.DataFrame, state_code: str) -> pd.DataFrame:
       """Filter DataFrame to orgs in a specific state before enrichment."""
       logger.info("=" * 60)
       logger.info(f"STATE FILTER: Filtering to {state_code}")
       logger.info("=" * 60)

       # Case-insensitive state matching (IRS BMF uses uppercase, other sources may vary)
       mask = df["state"].str.upper() == state_code.upper()
       filtered = df[mask].copy()

       logger.info(f"State filter: {len(filtered):,} of {len(df):,} orgs "
                    f"({len(filtered)/max(len(df),1)*100:.1f}%)")

       if len(filtered) == 0:
           logger.warning(f"No orgs found for state '{state_code}'. "
                          "Check that the state column contains 2-letter codes.")

       return filtered
   ```

3. **Wire the filter into the pipeline** in the `main()` function, between Stage 6 and Stage 7:
   - After Stage 6 dedup completes and before Stage 7 enrichment runs
   - Apply the filter if `args.state_filter` is provided
   - Store the full DataFrame separately so Stage 8 can output it (the filter is only for enrichment scope reduction)
   - Pass the filtered DataFrame to Stage 7, then merge enrichments back into the full DataFrame

   Specifically, in the `try` block of `main()`, replace the Stage 7 section with:
   ```python
   # Stage 7: Web enrichment (optional)
   if 7 in run_stages:
       if args.state_filter:
           enrichment_df = filter_by_state(merged, args.state_filter)
           enrichment_df = stage7_enrichment(enrichment_df)
           # Merge enrichments back into full dataset
           merged.update(enrichment_df)
       else:
           merged = stage7_enrichment(merged)
   ```

   Use `df.update()` to copy non-NaN values from the enriched subset back into the full DataFrame. This preserves all 80K orgs in the output while only enriching the filtered subset.

Important: The `state` column is used by IRS BMF data and should contain 2-letter state codes. Use `str.upper()` for case-insensitive matching per research pitfall #2.
  </action>
  <verify>
Verify the filter function works correctly:
```bash
cd /Users/vincecain/Projects/vet_org_directory
python3 -c "
import pandas as pd
# Simulate a DataFrame with state column
df = pd.DataFrame({
    'org_name': ['Org A', 'Org B', 'Org C', 'Org D'],
    'state': ['KY', 'OH', 'ky', 'KY'],
    'website': ['http://a.com', 'http://b.com', None, 'http://d.com']
})
# Import the filter function
import importlib
import main
importlib.reload(main)
result = main.filter_by_state(df, 'KY')
assert len(result) == 3, f'Expected 3 KY orgs, got {len(result)}'
print('PASS: Kentucky filter works (case-insensitive)')
"
```

Verify CLI argument is accepted:
```bash
cd /Users/vincecain/Projects/vet_org_directory
python3 main.py --help | grep -A1 "state-filter"
```
  </verify>
  <done>
Pipeline has a `filter_by_state()` function that filters orgs by 2-letter state code (case-insensitive). The `--state-filter KY` CLI flag causes enrichment to run only on Kentucky orgs while preserving the full dataset for output. Running without `--state-filter` processes all orgs (backward compatible).
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tqdm progress bar and update checkpoint interval for enricher</name>
  <files>config/settings.py, transformers/enricher.py</files>
  <action>
Update the enrichment loop to show a tqdm progress bar with time estimates, and reduce the checkpoint interval from 500 to 100.

1. **Update `config/settings.py`** -- Change `CHECKPOINT_INTERVAL` from 500 to 100:
   ```python
   CHECKPOINT_INTERVAL = 100  # save every N operations (reduced from 500 for web scraping)
   ```
   Add a comment explaining the change. Web scraping at 0.5 req/sec means each checkpoint is ~200 seconds of work -- losing more than that on crash is unacceptable.

2. **Update `transformers/enricher.py`** -- Add tqdm progress bar to the enrichment loop:

   a. Add import at top of file:
   ```python
   from tqdm import tqdm
   ```

   b. Replace the bare `for count, idx in enumerate(remaining):` loop (line 84) with tqdm-wrapped version:
   ```python
   for count, idx in enumerate(tqdm(
       remaining,
       desc="Enriching websites",
       unit="org",
       initial=len(done_indices),
       total=len(needs_enrichment),
   )):
   ```

   The `initial` and `total` parameters make tqdm show progress relative to the FULL job (not just remaining), so resumed runs show accurate completion percentage.

   c. Replace the `self.logger.info(f"Enrichment progress: ...")` inside the checkpoint block (lines 97-99) with `tqdm.write()` to avoid garbled output:
   ```python
   if (count + 1) % CHECKPOINT_INTERVAL == 0:
       save_checkpoint("enricher_partial", (enrichments, done_indices))
       tqdm.write(
           f"  Checkpoint saved: {len(done_indices):,}/{len(needs_enrichment):,} orgs processed"
       )
   ```

   d. Keep the final `self.logger.info(f"Enrichment complete: ...")` after the loop (line 107-109) as-is -- it runs after tqdm finishes so no collision.

Important per research pitfall #5: Use `tqdm.write()` instead of `self.logger.info()` inside the tqdm loop to prevent progress bar and log messages from colliding in the terminal.

Important per research pitfall #4: Keep `enumerate(tqdm(remaining))` pattern. Checkpoint triggers at `(count + 1) % 100 == 0`, which means first checkpoint at iteration 100 (0-indexed count 99, +1 = 100).
  </action>
  <verify>
Verify checkpoint interval is updated:
```bash
cd /Users/vincecain/Projects/vet_org_directory
python3 -c "
from config.settings import CHECKPOINT_INTERVAL
assert CHECKPOINT_INTERVAL == 100, f'Expected 100, got {CHECKPOINT_INTERVAL}'
print('PASS: CHECKPOINT_INTERVAL is 100')
"
```

Verify tqdm is imported and used in enricher:
```bash
cd /Users/vincecain/Projects/vet_org_directory
python3 -c "
import ast
with open('transformers/enricher.py') as f:
    source = f.read()
assert 'from tqdm import tqdm' in source, 'tqdm not imported'
assert 'tqdm(' in source, 'tqdm not used in loop'
assert 'tqdm.write' in source, 'tqdm.write not used for logging in loop'
print('PASS: tqdm properly integrated in enricher')
"
```

Verify enricher module still imports cleanly:
```bash
cd /Users/vincecain/Projects/vet_org_directory
python3 -c "
from transformers.enricher import WebEnricher
print('PASS: WebEnricher imports successfully')
"
```
  </verify>
  <done>
Enricher shows a tqdm progress bar with "Enriching websites: 45%|####5     | 450/1000 [07:30<09:10, 1.00org/s]" format including estimated time remaining. Checkpoints save every 100 orgs (not 500). Resumed runs show accurate progress relative to total job size. Log messages inside the loop use `tqdm.write()` to avoid garbled terminal output.
  </done>
</task>

</tasks>

<verification>
1. `python3 main.py --help` shows `--state-filter` argument
2. `main.py` contains `filter_by_state()` function with case-insensitive state matching
3. `config/settings.py` has `CHECKPOINT_INTERVAL = 100`
4. `transformers/enricher.py` imports and uses `tqdm` in the enrichment loop
5. `transformers/enricher.py` uses `tqdm.write()` for in-loop logging
6. All three files import cleanly without errors
</verification>

<success_criteria>
- Running `python3 main.py --state-filter KY --stages 7 --skip-enrichment` shows the state filter argument is accepted
- `CHECKPOINT_INTERVAL` reads as 100 from settings
- `WebEnricher` class imports without errors and has tqdm in its enrich method
- tqdm progress bar would display during actual enrichment (manual verification deferred to Phase 2 integration)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-kentucky-filtering/01-02-SUMMARY.md`
</output>
